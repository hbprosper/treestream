//----------------------------------------------------------------------------
// File: treestream.cc
//
// Description: The classes itreestream and otreestream provide a convenient 
//              interface to the kind of Root-trees typically used in 
//              analyses in Dzero and CMS. All the boilerplate code for 
//              getting at the tree, its branches and its leaves is hidden
//              from the user.
//
//              The design is based on the observation that, ultimately, data
//              reduce to a set of name/value pairs in which the value 
//              can be regarded as a homogeneous sequence of doubles, floats 
//              or ints. Moreover, an arbitrarily complex graph of the 
//              name/value pairs is readily achieved with, well, name/value 
//              pairs! Name/value pair is just another name for variable.
// 
//              Thinking in terms of objects, in the context of high energy 
//              physics analysis, has yielded great complexity. On the other 
//              hand, thinking in terms of name/value pairs reduces the 
//              complexity enormously. The irreducible complexity, which 
//              surely exists, properly resides in the graph generated by 
//              the set of name/value pairs, that is, variables.
//
//              Of course, it is often convenient to package name/value pairs 
//              into objects to avail oneself of their useful behaviour. This 
//              may be useful, for example, to model a particularly 
//              complicated sub-graph of name/value pairs. Sometimes this is
//              useful if an object defines functions on the name/value pairs.
//              A  nice example of packaging name/value pairs for this reason
//              is the packaging of the name/value pairs, Px, Py, Pz and E 
//              into TLorentzVector objects, which provides a host of useful 
//              mathematical operations on them.
//
// Created: 19-Feb-2005 Harrison B. Prosper, based on 12-Mar-2001 version of
//                      the same.
//          14-Jul-2005 HBP Make even simpler!
//          13-Aug-2005 HBP ..and simpler still!
//          30-Nov-2005 HBP fix counter loading bug
//          31-Oct-2009 HBP allow use of regexes in branch names
//                      fix looping bug so operator[] works for Python
//          02-Oct-2010 HBP minor change to itreestream to handle vector types
//                      directly.
//          22-Nov-2010 HBP allow reading of multiple trees
//          22-Nov-2011 HBP handle reading/storing of strings
//          03-Dec-2017 HBP write out leaf counter name in listing.
//          21-Feb-2018 HBP fix getenv call
//          22-Feb-2018 HBP make sure correct tree is called for branches
//                      that may come from different trees.
//          02-Mar-2018 HBP fix interaction between chains and friendly trees
//                      at 35,000 feet!
//          20-Sep-2018 HBP remember to set fullname in _add function.
//                          possible compiler issue: wrong overloaded function
//                          called, namely, float version of add when int version
//                          requested. this caused the counter variables to fail.
//                          the int version. placing int version of add function
//                          before float version corrects the problem. (using
//                          clang++ version clang-802.0.42.
//          20-Jan-2019 HBP avoid ROOT warning when handling stored vector types.
//          23-Jun-2019 HBP allow reading of simple STL vector types from file.
//          18-Jan-2020 HBP in ROOT 6.16/00 it seems one must store leaf counter
//                          explicitly. 
//----------------------------------------------------------------------------
#ifdef PROJECT_NAME
#include <boost/regex.hpp>
#include <glob.h>
#endif

#include <map>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <typeinfo>
#include <cctype>
#include <cassert>


#include "TROOT.h"
#include "TList.h"
#include "TKey.h"
#include "TFile.h"
#include "TLeaf.h"
#include "TDirectory.h"
#include "TTree.h"
#include "TClass.h"
#include "TChain.h"
#include "TString.h"
#include "TList.h"
#include "TIterator.h"
#include "TFriendElement.h"
#include "TString.h"
#include "TPRegexp.h"
#include "TClassEdit.h"
#include "TObjArray.h"
#include "TObjString.h"

#ifdef PROJECT_NAME
#include "PhysicsTools/TheNtupleMaker/interface/treestream.h"
#else
#include "treestream.h"
#endif
//----------------------------------------------------------------------------
using namespace std;

// Status codes

const int kSUCCESS=0;
const int kBADOPEN=1;
const int kBADTREE=2;
const int kBADBRANCH=3;
int DEBUGLEVEL=0;

// Make following visible only to this compilation unit.

namespace 
{
  void fatal(string message)
  {
    cout << "** Error ** " << message << endl;
    exit(1);
  }

  void warning(string message)
  {
    cout << "** Warning ** " << message << endl;
  }

  string blank("                                                            ");

  void DBUG(string message, int level=1)
  {
    if ( getenv("DBtreestream") != (char*)0 )
      DEBUGLEVEL = atoi(getenv("DBtreestream"));
    else
      DEBUGLEVEL = 0;
    if ( DEBUGLEVEL >= level ) cout << message << endl;
  }

  void split(string str, vector<string>& vstr)
  {
    vstr.clear();
    istringstream stream(str);
    while ( stream )
      {
        string strg;
        stream >> strg;
        if ( stream ) vstr.push_back(strg);
      }
  }
 
  // For given leaf, find maximum number of items.
  int getmaxsize(TLeaf* leaf)
  {
    int count = 0;
    TLeaf* leafcounter = leaf->GetLeafCounter(count);
    if ( leafcounter != 0 )
      // Variable length array
      return leafcounter->GetMaximum();
    else
      // Either fixed length array or a simple variable
      return leaf->GetLen();
  }

  // ----------------------------------------------------------------------
  // return value of given external buffer
  // T is type of external buffer
  // ----------------------------------------------------------------------
  template <class T>
  inline
  T
  exvalue(Field* field, int index=0)
  {
    T val;
    if ( field->isvector )
      {
        vector<T>* d = reinterpret_cast<vector<T>*>(field->address);
        if ( d == 0 ) fatal("exvalue - reinterpret_cast failed" + 
                            string(field->branch->GetName()));
        val = (*d)[index];
      }
    else
      {
        T* d = reinterpret_cast<T*>(field->address);
        if ( d == 0 ) fatal("exvalue - reinterpret_cast failed " + 
                            string(field->branch->GetName()));
        val = *d;
      }
    if ( DEBUGLEVEL > 0 )
      cout << "\texternal value(" << val << ")" << endl;
    return val;
  }

  template <class T>
  inline
  int
  exsize(Field* field)
  {
    int val = 1;
    if ( field->isvector )
      {
        vector<T>* d = reinterpret_cast<vector<T>*>(field->address);
        if ( d == 0 ) fatal("exvalue - reinterpret_cast failed" + 
                            string(field->branch->GetName()));
        val = d->size();
        //
        if ( DEBUGLEVEL > 1 )
          cout << "EXSIZE(" << val << ") " 
               << string(field->branch->GetName()) << endl;
      }
    return val;
  }


  string 
  getiotype(Field* field)
  {
    char iotype[2]; iotype[0] = field->iotype;  iotype[1] = 0;
    return string(iotype);
  }

  string 
  getsrctype(Field* field)
  {
    char srctype[2]; srctype[0] = field->srctype; srctype[1] = 0;
    return string(srctype);
  }

  int
  getexsize(Field* field)
  {
    int size = 0;
    switch(field->srctype)
      {
      case 'D':
        size = exsize<double>(field);
        break;
        
      case 'F':
        size = exsize<float>(field);
        break;

      case 'L':
        size = exsize<long>(field);
        break;
              
      case 'I':
        size = exsize<int>(field);           

      case 'S':
        size = exsize<short>(field);
     
      case 'B':
        size = exsize<char>(field);

      case 'O':
        size = exsize<bool>(field);

      case 'C':
        size = exsize<string>(field);
     
      case 'l':
        size = exsize<unsigned long>(field);
        break;
        
      case 'i':
        size = exsize<unsigned int>(field);
        break;
   
      case 's':
        size = exsize<unsigned short>(field);
        break;

      case 'b':
        size = exsize<unsigned char>(field);

      default:
        size = exsize<double>(field);
        break;
      }
    return size;
  }

  // ----------------------------------------------------------------------
  // Copy from external buffer to internal buffer.
  // Note: T is the type of the internal buffer
  // ----------------------------------------------------------------------

  template <class T>
  inline
  void
  fromexternal(Field* field)
  {
    assert(field);
    
    int count = field->size;
    
    if ( DEBUGLEVEL > 0 )
      {
        char preamble[160];
        sprintf(preamble,
                "BEGIN fromexternal\n\t%-16s (%s <- %s) count = %d",
                field->leaf->GetName(), 
                getiotype (field).c_str(),
                getsrctype(field).c_str(),
                count);
        cout << preamble << endl;
      }        
    
    FieldBuffer<T>* d = dynamic_cast<FieldBuffer<T>*>(field);
    if ( d == 0 ) fatal("fromexternal - dynamic_cast failed " + 
                        string(field->branch->GetName()));
    
    switch(field->srctype)
      {
      case 'D':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<double>(field, i));
        break;
        
      case 'F':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<float>(field, i));
        break;
        
      case 'L':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<long>(field, i));
        break;

      case 'I':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<int>(field, i));
        break;

      case 'S':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<short>(field, i));
        break;
        
      case 'B':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<char>(field, i));
        break;

      case 'O':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<bool>(field, i));
        break;

      case 'l':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<unsigned long>(field, i));
        break;
        
      case 'i':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<unsigned int>(field, i));
        break;

      case 's':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<unsigned short>(field, i));
        break;

      case 'b':
        for(int i=0; i < count; i++)
          d->value[i] = static_cast<T>(exvalue<unsigned char>(field, i));
        break;
        
      }
    
    if ( DEBUGLEVEL > 0 )
      {
        cout << "\tinternal value = " << d->value[0] << endl;
        cout << "END fromexternal" << endl;
      }
  }


  template <>
  inline
  void
  fromexternal<string>(Field* field)
  {
    int count = field->size;
    
    if ( DEBUGLEVEL > 0 )
      {
        char preamble[160];
        sprintf(preamble,
                "BEGIN fromexternal\n\t%-16s (%s <- %s) count = %d",
                field->leaf->GetName(), 
                getiotype (field).c_str(),
                getsrctype(field).c_str(),
                count);
        cout << preamble << endl;
      }        
    
    FieldBuffer<string>* d = dynamic_cast<FieldBuffer<string>*>(field);

    if ( d == 0 ) fatal("fromexternal - dynamic_cast failed " + 
                        string(field->branch->GetName()));

    // IMPORTANT: use c_str() so that bytes are copied into existing
    // string.
    for(int i=0; i < count; i++)
      d->value[i] = exvalue<string>(field, i).c_str();
    
 
    if ( DEBUGLEVEL > 0 )
      {
        cout << "\tinternal value(" << d->value[0] << ")" << endl;
        void* address = (void*)(d->value[0].c_str());
        cout << "\tAddr(d->value[0].c_str()): " << address << endl;
        cout << "END fromexternal" << endl;
      }
  }

  // ----------------------------------------------------------------------
  // Copy to external buffer from internal buffer.
  // Note: T is the type of the external buffer
  //       Make sure external buffer is of the correct size
  // ----------------------------------------------------------------------
  template <class T>
  inline
  void
  toexternal(Field* field)
  {
    // GetLenStatic returns the number of elements/leaf
    // GetLen returns the total number of elements/leaf.
    // Therefore, the number of leaves/branch is GetLen / GenLenStatic
    int count_per_leaf = field->leaf->GetLenStatic();
    int total_count_per_leaf = field->leaf->GetLen();
    int count = total_count_per_leaf / count_per_leaf;
    //count = min(count, field->maxsize);

    if ( DEBUGLEVEL > 0 )
      {
        char preamble[160];
        sprintf(preamble,
                "toexternal\n %-16s (%s -> %s) count = %d, "
		"GetLen() = %d, GetLenStatic() = %d",
                field->leaf->GetName(), 
                getiotype (field).c_str(),
                getsrctype(field).c_str(),
                count,
		total_count_per_leaf,
		count_per_leaf);
        cout << preamble << endl;
      }        

    // Make sure external buffer is of the correct size

    if ( field->isvector )
      {
	// if count_per_leaf == 1, then we assume the return buffer
	// is vector<T>, in which case field->isvector = 1
	//
	// if count_per_leaf > 1, then we assume the return buffer
	// if vector<vector<T> >, in which case field->isvector should be 2
	if ( count_per_leaf == 1 )
	  {
	    // vector<T>
	    
	    vector<T>* ptr = reinterpret_cast<vector<T>*>(field->address);
	    if ( ptr == 0 ) fatal("toexternal - reinterpret_cast failed" + 
				string(field->fullname));
	    
	    // NOTE: d is the same object as *ptr
	    vector<T>& d = *ptr;
	    
	    if ( (int)d.size() != count ) d.resize(count, 0);
        
	    if ( (int)d.size() != count ) 
	      fatal("toexternal - unable to resize external buffer for " + 
		    field->leafname);
        
	    for(int index=0; index < count; index++)
	      d[index] = static_cast<T>(field->leaf->GetValue(index));

	    if ( DEBUGLEVEL > 0 )
	      {
		for(size_t ii=0; ii < d.size(); ii++)
		  cout << "\ttoexternal "
		       << field->fullname << "[" << ii << "]\t"
		       << d[ii] << endl;		  
	      }
	  }
	else
	  {
	    // vector<vector<T> >

	    vector<vector<T> >* ptr = reinterpret_cast<vector<vector<T> >*>(field->address);
	    if ( ptr == 0 ) fatal("toexternal - reinterpret_cast failed" + 
				string(field->fullname));

	    // NOTE: d is the same object as *ptr
	    vector<vector<T> >& d = *ptr;
	    
	    int index = 0;
	    d.clear();
	    vector<T> v(count_per_leaf);
	    
	    for(int ii=0; ii < count; ii++)
	      {
		for(size_t jj=0; jj < v.size(); jj++)
		  {
		    v[jj] = static_cast<T>(field->leaf->GetValue(index));
		    index++;
		  }
		d.push_back(v);
	      }

	    if ( DEBUGLEVEL > 0 )
	      {
		for(size_t ii=0; ii < d.size(); ii++)
		  {
		    for(size_t jj=0; jj < d[ii].size(); jj++)
		      cout << "\ttoexternal "
			   << field->fullname << "[" << ii << "][" << jj <<  "]\t"
			   << d[ii][jj] << endl;
		  }
	      }
	  }
      }
    else
      {
        T* d = reinterpret_cast<T*>(field->address);
        if ( d == 0 ) fatal("toexternal - reinterpret_cast failed" + 
                            string(field->fullname));
        
        *d = static_cast<T>(field->leaf->GetValue());

        if ( DEBUGLEVEL > 0 )
          {
            cout << "\ttoexternal " << field->fullname << "\t" << *d;
            if ( field->iscounter ) cout << " (counter)";
            cout << endl;
          }
      }
    if ( DEBUGLEVEL > 0 )
      cout << "END toexternal" << endl;
  }

  template <>
  inline
  void
  toexternal<string>(Field* field)
  {
    int count = field->leaf->GetLen();

    if ( DEBUGLEVEL > 0 )
      {
        char preamble[160];
        sprintf(preamble,
                "BEGIN toexternal\n\t%-16s (%s -> %s) maxsize = %d",
                field->leaf->GetName(), 
                getiotype (field).c_str(),
                getsrctype(field).c_str(),
                count);
        cout << preamble << endl;
      }        

    // Make sure external buffer is of the correct size

    string* d = reinterpret_cast<string*>(field->address);
    if ( d == 0 ) fatal("toexternal - reinterpret_cast failed" + 
                        string(field->fullname));
        
    d->assign(count, 0); // assign new content to string
    int size=0;
    for(int index=0; index < count; index++)
      {
        (*d)[index] = static_cast<char>(field->leaf->GetValue(index));
        if ( (*d)[index] == 0 ) break;
        size++;
      }
    d->resize(size);

    if ( DEBUGLEVEL > 0 )
      cout << "\texternal value = " << *d << endl;

    if ( DEBUGLEVEL > 0 )
      cout << "END toexternal" << endl;
  }

  // ----------------------------------------------------------------------
  // IMPORTANT: In tree->Branch(..), it is necessary to use the correct 
  // type when giving the address of the variable from which data are to 
  // be read, otherwise tree->Fill() gets really confused and can even hang
  // your computer!
  // ----------------------------------------------------------------------


  template <class T>
  inline
  void
  createbranch(TTree* tree, Field* field, 
               const char* FMT, 
               SelectedData& selecteddata)
  {
    DBUG("\tcreatebranch: BEGIN");

    if ( tree == 0 ) fatal("createbranch - tree pointer is zero ");
    if ( field == 0 ) fatal("createbranch - field pointer is zero ");

    string format(FMT);
    
    FieldBuffer<T>* v = new FieldBuffer<T>();
    assert(v != 0);

    v->skip      = false;
    v->iotype    = field->iotype;
    v->srctype   = field->srctype;
    v->address   = field->address;
    v->isvector  = field->isvector;
    v->maxsize   = field->maxsize;    
    v->treename  = field->treename;
    v->fullname  = field->fullname;
    v->branchname= field->branchname;
    v->countername = field->countername;
    
    v->iscounter = false;
    v->leafname  = ""; 
    v->branch    = 0;
    v->leaf      = 0;
    v->size      = 0;
    
    TBranch* branch = 0;

    v->value.clear();
    v->value.reserve(v->maxsize);
    v->value.resize(v->maxsize, 0);
    //DEBUG
    if ( DEBUGLEVEL > 0 )
      {
	cout << "\tcreatebranch: fullname: " << v->fullname << endl;
	cout << "\tcreatebranch: maxsize:  " << v->value.size() << endl;
	cout << "\tcreatebranch: address:  " << v->address << endl;
	cout << "\tcreatebranch: format:   " << format << endl;
      }

    // Store in map
    selecteddata[v->fullname] = v;

    // check if we need to create a leaf counter. for vectors only
    if ( v->isvector )
      {
	string cname = v->countername;
	if ( cname == "" ) cname = v->fullname + "_size";
	v->countername = cname;
	
	if ( selecteddata.find(cname) == selecteddata.end() )
	  {
	    // we need to create a leaf counter
	    if ( DEBUGLEVEL > 0 )
	      cout << "\tcreatebranch: create leaf counter: " << cname << endl;

	    FieldBuffer<int>* l = new FieldBuffer<int>();
	    assert(l != 0);
	    
	    l->iotype    = 'I';
	    l->srctype   = 'I';
	    l->address   = &l->size; // NB: address of count
	    l->isvector  = 0;
	    l->maxsize   = 1;
	    l->treename  = field->treename;
	    l->fullname  = cname;
	    l->branchname= cname;
	    l->countername = "";  // a leaf counter does not have a leaf counter!
	    
	    l->iscounter = true;
	    l->skip      = false;
	    l->leafname  = ""; 
	    l->branch    = 0;
	    l->leaf      = 0;
	    l->size      = 1;
	
	    // Store in map
	    selecteddata[l->fullname] = l;
	    
	    char fmt[256];
	    sprintf(fmt, "%s/I", l->fullname.c_str());
	    tree->Branch(l->fullname.c_str(), l->address, fmt);
    
	    l->branch = tree->GetBranch(l->fullname.c_str());
	    if ( l->branch == 0 ) fatal("createbranch - unable create branch " + 
					l->fullname);
    
	    l->leaf   = l->branch->GetLeaf(l->fullname.c_str());
    
	    assert(l->leaf);

	    // update format of vector variable
	    int k = format.find("[");
	    if ( k < 0 )
	      {
		k = format.find("/");
		string name = format.substr(0, k);
		char IOtype[2] = {v->iotype, 0};
		sprintf(fmt, "%s[%s]/%s", name.c_str(), cname.c_str(), IOtype);		
		format = string(fmt);
	      }
	  }
	else
	  {
	    // leaf counter already exists
	    selecteddata[cname]->iscounter = true;
	  }
      }
    
    // IMPORTANT: need address of first element of vector, not of the
    // vector itself
    void* address = &(v->value[0]);
    tree->Branch(v->fullname.c_str(), address, format.c_str());
    
    branch = tree->GetBranch(v->fullname.c_str());
    if ( branch == 0 ) fatal("createbranch - unable create branch " + 
			     v->fullname);
    
    v->branch = branch;
    v->leaf   = branch->GetLeaf(v->fullname.c_str());
    
    assert(v->leaf);

    DBUG("\tcreatebranch: END");
  }
 

  template <>
  inline
  void
  createbranch<string>(TTree* tree, Field* field, 
                       const char* format, 
                       SelectedData& selecteddata)
  {
    DBUG("\tcreatebranch: BEGIN");

    if ( tree == 0 ) fatal("createbranch - tree pointer is zero ");
    if ( field == 0 ) fatal("createbranch - field pointer is zero ");

    FieldBuffer<string>* v = new FieldBuffer<string>();
    assert(v != 0);

    v->iotype  = field->iotype;
    v->srctype = field->srctype;
    v->address = field->address;
    v->isvector= field->isvector;
    v->maxsize = field->maxsize;

    v->treename  = field->treename;
    v->fullname  = field->fullname;
    v->branchname= field->branchname;
    
    v->iscounter= false;
    v->skip     = false;
    v->size     = 1;    
    v->branch   = 0;
    v->leaf     = 0;
    v->leafname = ""; 
    
    string* d = reinterpret_cast<string*>(field->address);
    if ( d == 0 ) fatal("createbranch - reinterpret_cast failed " + 
                        string(field->fullname));
    v->value.clear();
    v->value.reserve(v->maxsize);
    v->value.resize(v->maxsize, *d);

    if ( DEBUGLEVEL > 0 )
      {
        cout << "\tcreatebranch: init value(" << v->value[0] << ")" << endl;
        cout << "\tcreatebranch: maxsize:   " << v->value.size() << endl;
      }
    // Store in map
    selecteddata[v->fullname] = v;

    DBUG("\tcreatebranch: " + v->fullname + "\t" + format);

    void* address = (void*)(v->value[0].c_str());
    tree->Branch(v->fullname.c_str(), address, format);

    TBranch* branch = tree->GetBranch(v->fullname.c_str());
    if ( branch == 0 ) fatal("createbranch - unable create branch " + 
                             v->fullname);

    v->branch = branch;
    v->leaf   = branch->GetLeaf(v->fullname.c_str());
    assert(v->leaf);

    DBUG("\tcreatebranch: END");
  }


  void 
  readbranch(Field* field, int entry)
  {
    assert(field != 0);
    if ( field->branch == 0 ) return;

    // Read entry for current branch

    field->branch->GetEntry(entry);

    // If address field is zero, this signals that 
    // the caller has not provided a location into which 
    // the value of the current variable is to be written.
    // This should happen only for leaf counter variables.
    // In this case, just return

    if ( field->address == 0) return;

    // If this is intrinsically a vector type, we let Root handle it
    // directly
    if ( field->iotype == 'v' ) return;
    
    // Copy data from internal to external buffers
    // iotype -> srctype

    switch(field->srctype)
      {
      case 'D':
        toexternal<double>(field);
        break;
	
      case 'F':
        toexternal<float>(field);
        break;
        
      case 'L':
        toexternal<long>(field);
        break;
        
      case 'I':
        toexternal<int>(field);
        break;
        
      case 'S':
        toexternal<short>(field);
        break;

      case 'B':
        toexternal<char>(field);
        break;

      case 'O':
        toexternal<bool>(field);
        break;

      case 'C':
        toexternal<string>(field);
        break;
	
      case 'l':
        toexternal<unsigned long>(field);
        break;
	
      case 'i':
        toexternal<unsigned int>(field);
        break;

      case 's':
        toexternal<unsigned short>(field);
        break;

      case 'b':
        toexternal<unsigned char>(field);
        break;
	
      default:
        toexternal<double>(field);
        break;
      }
  }
}


// Default constructor

itreestream::itreestream()
  : _tree(0),
    _chain(0),
    _statuscode(kSUCCESS),
    _current(-1),
    _entries(0),
    _entry(0),
    _index(0),
    _buffer(vector<double>(1000)),
    data(Data()),
    selecteddata(SelectedData()),
    _delete(true),
    _treename(""),
    _treenames(vector<string>())
{}


itreestream::itreestream(string filename_, string treename, int bufsize)
  : _tree(0),
    _chain(0),
    _statuscode(kSUCCESS),
    _current(-1),
    _entries(0),
    _entry(0),
    _index(0),
    _buffer(vector<double>(bufsize)),
    data(Data()),
    selecteddata(SelectedData()),
    _delete(true),
    _treename(""),
    _treenames(vector<string>())    
{
  vector<string> fname;
  split(filename_, fname);
  vector<string> tname;
  if ( treename != "" )
    split(treename, tname);
  _open(fname, tname);
}

itreestream::itreestream(vector<string>& fname, string treename, int bufsize)
  : _tree(0),
    _chain(0),
    _statuscode(kSUCCESS),
    _current(-1),
    _entries(0),
    _entry(0),
    _index(0),
    _buffer(vector<double>(bufsize)),
    data(Data()),
    selecteddata(SelectedData()),
    _delete(true),
    _treename(""),
    _treenames(vector<string>())    
{
  vector<string> tname;
  if ( treename != "" )
    split(treename, tname);
  _open(fname, tname);
}

vector<string>
itreestream::treenames() { return _treenames; }

void
itreestream::init(TTree* tree_)
{
  _delete = false;
  _tree = tree_;
  vector<string> fname;
  vector<string> tname;
  _open(fname, tname);
}

// ------------------------------------------------------------------------
// R E A D
// ------------------------------------------------------------------------
// Handle wildcarded filenames.
// 1. Use glob to get first filename
// 2. Get tree from file
// 3. Create a chain
// ------------------------------------------------------------------------
void
itreestream::_open(vector<string>& fname, vector<string>& tname)
{
  DBUG("itreestream::ctor - BEGIN", 1);

  // Clear internal buffer

  _buffer.clear();

  if ( tname.size() > 0 )
    _treename = tname[0];
  else
    _treename = string("");  

  // If tree pointer is zero, get tree from file
  if ( _tree == 0 )
    {
      // ----------------------------------------
      // Get list of files
      // Format of filename:
      // file1 file2 ..
      // ----------------------------------------
      filepath.clear();
#ifdef PROJECT_NAME
      for(int i=0; i < (int)fname.size(); ++i)
        {
          glob_t g;
          glob(fname[i].c_str(), GLOB_ERR | GLOB_NOCHECK, NULL, &g);
          for (int j=0; j < (int)g.gl_pathc; ++j)
            filepath.push_back(g.gl_pathv[j]);
          globfree(&g);
        }
#else
     for (size_t j=0; j < fname.size(); ++j)
       {
	 filepath.push_back(fname[j]);
       }
#endif
      DBUG("itreestream::ctor - TFile::Open ");
  
      // ----------------------------------------
      // Open first file
      // ----------------------------------------
      TFile* file_ = TFile::Open(filepath[0].c_str());
      if ( ! file_ || (file_ != 0 && ! file_->IsOpen()) )
        fatal("itreestream - unable to open file " + filepath[0]);
      file_->cd();


      // get all tree names
      DBUG("itreestream::ctor - before _gettree");
      _gettree(file_);
      DBUG("itreestream::ctor - after _gettree");

      if ( tname.size() == (size_t)0 )
        {
          // ----------------------------------------
          // No tree name was given. Here is the default
          // action: Use the first tree found and warn
	  // user.
          // ----------------------------------------
	  tname.resize(1);
	  tname[0]  = _treenames[0];
	  _treename = _treenames[0];
	  _tree = (TTree*)file_->Get(_treename.c_str());
          if ( ! _tree )
            fatal("itreestream - NO tree found in file " + filepath[0]);
          
          cout << "** WARNING ** itreestream - tree not given; using tree: " 
               << _treename << endl;
        }
      else if ( TString(tname[0].c_str()).Contains("*") )
	{
          // ----------------------------------------
          // All trees requested
          // ----------------------------------------	  
	  tname.resize(_treenames.size());
	  copy(_treenames.begin(), _treenames.end(), tname.begin());
	  _treename = _treenames[0];
	  _tree = (TTree*)file_->Get(_treename.c_str());
          if ( ! _tree )
            fatal("itreestream - NO tree found in file " + filepath[0]);	  
	}
      else
	{
          // ----------------------------------------
          // At least one tree requested
          // ----------------------------------------	  
	  _treename = tname[0];
	  _tree = (TTree*)file_->Get(_treename.c_str());
          if ( ! _tree )
            fatal("itreestream - NO tree found in file " + filepath[0]);	  
	}	
      
      string message("itreestream::ctor - treename: " + _treename);
      DBUG(message);

      // Remember to close file. It will be re-opened as part of a
      // chain.

      file_->Close();
      
      DBUG("itreestream::ctor - after file->Close");

      // ----------------------------------------
      // Create a chain of files
      // ----------------------------------------
      // WARNING: This might be slow for large chains. 

      
      DBUG("itreestream::ctor - new TChain", 2);
      _chain = new TChain(tname[0].c_str());
      if ( ! _chain ) fatal("itreestream - Unable to create chain");
      for(size_t i=0; i < filepath.size(); i++)
	_chain->Add(filepath[i].c_str());
      _chainmap[tname[0]] = _chain;

      // ----------------------------------------
      // Add possible friendly trees
      // ----------------------------------------
      for(size_t i=1; i < tname.size(); i++)
        {
          DBUG("itreestream::ctor - AddFriend " + tname[i], 2);
          _chainmap[tname[i]] = new TChain(tname[i].c_str());
	  for(size_t j=0; j < filepath.size(); j++)
	    _chainmap[tname[i]]->Add(filepath[j].c_str());	  
          _chain->AddFriend(_chainmap[tname[i]]);
        }
      
      DBUG("itreestream::ctor - GetEntries", 2);
      _entries = _chain->GetEntries();
      
      // ----------------------------------------
      // Update tree pointer
      // ----------------------------------------
      _tree = _chain; 
    }

  // ----------------------------------------
  // Get all branches and create a data
  // structure (Field) for every leaf. For 
  // leaves whose names differ from the branch, 
  // use the syntax:
  //    <branchname>.<leafname> 
  // ----------------------------------------
  if ( DEBUGLEVEL > 0 )
    cout << "itreestream::ctor - number of trees: " << tname.size() << endl;
								       
  for(size_t k=0; k < tname.size(); k++)
    {
 
      TChain* chain = _chainmap[tname[k]];
      TObjArray* array = chain->GetListOfBranches();
      if ( !array ) fatal("itreestream::ctor - "
                          "Unable to GetListOfBranches for " +
                          string(chain->GetName()));

      int nitems = array->GetEntries();

      if ( DEBUGLEVEL > 0 )
        {
          char message[80];
          sprintf(message, "itreestream::ctor - number of branches in tree %s: %d", 
                  tname[k].c_str(), nitems);
          cout << message << endl;
        }

      for (int i = 0; i < nitems; i++)
        {
          TBranch* branch = (TBranch*)((*array)[i]);      
          _getbranches(branch, 0);
        }
    }

  // ----------------------------------------
  // Flag branches that are leaf counters
  // ----------------------------------------
  Data::iterator it;
  for(it=data.begin(); it != data.end(); it++)
    {
      int count = 0;
      TLeaf* leafcounter = it->second.leaf->GetLeafCounter(count);
      if ( leafcounter != 0 )
	{
	  string fullname = it->second.treename + "/" +
	    leafcounter->GetBranch()->GetName();
	  if ( data.find(fullname) != data.end() )
	    {
	      data[fullname].iscounter = true;
	    }
	}
    }

  if ( DEBUGLEVEL > 0 ) 
    cout << "itreestream::ctor - DATA.COUNT(" << data.size() << ")" << endl;

  DBUG("itreestream::ctor - exit OK", 1);
}

itreestream::~itreestream()
{
  _statuscode = kSUCCESS;
  close();
}

void
itreestream::_gettree(TDirectory* dir, int depth, string dirname)
{
  depth += 1;
  if ( depth > 5 ) return;

  DBUG("gettree(entered)");
  TIter nextkey(dir->GetListOfKeys());          
  while ( TKey* key = (TKey*)nextkey() )
    {
      TObject* o = key->ReadObj();
      if ( o->IsA()->InheritsFrom("TTree") )
	{
	  _tree = dynamic_cast<TTree*>(o);
	  _treenames.push_back(dirname + string(_tree->GetName()));
	  DBUG("gettree - tree: " + _treenames.back());
	}
      else if ( o->IsA()->InheritsFrom("TDirectory") )
	{
	  TDirectory* d = dynamic_cast<TDirectory*>(o);
	  DBUG("gettree - dirname: " + string(d->GetName()));
	  
	  if ( depth == 1 )
	    dirname  = string(d->GetName()) + "/";
	  else
	    dirname += string(d->GetName()) + "/";
	  _gettree(d, depth, dirname);
	}
    }
  return;
}

// void
// itreestream::_getbranches(TDirectory* dir, int depth, string dirname)
// {
//   depth += 1;
//   if ( depth > 10 ) return;

//   DBUG("getbranches(entered)");
//   TIter nextkey(dir->GetListOfKeys());          
//   while ( TKey* key = (TKey*)nextkey() )
//     {
//       TObject* o = key->ReadObj();
//       if ( o->IsA()->InheritsFrom("TTree") )
// 	{
// 	  _tree = dynamic_cast<TTree*>(o);
// 	  _treenames.push_back(dirname + string(_tree->GetName()));
// 	  DBUG("gettree - tree: " + string(_tree->GetName()));
// 	}
//       else if ( o->IsA()->InheritsFrom("TDirectory") )
// 	{
// 	  TDirectory* d = dynamic_cast<TDirectory*>(o);
// 	  DBUG("gettree - dir: " + string(d->GetName()));
	  
// 	  if ( depth == 1 )
// 	    dirname  = string(d->GetName()) + "/";
// 	  else
// 	    dirname += string(d->GetName()) + "/";
// 	  _gettree(d, depth, dirname);
// 	}
//     }
//   return;
// }


// string
// itreestream::_gettree(TDirectory* dir, string treename, int depth)
// {
//   depth += 1;
//   if ( depth > 5 ) return treename;

//   TIter nextkey(dir->GetListOfKeys());          
//   while ( TKey* key = (TKey*)nextkey() )
//     {
//       TObject* o = key->ReadObj();
//       if ( o->IsA()->InheritsFrom("TTree") )
// 	{
// 	  if ( _tree == 0 ) _tree = (TTree*)o; // Record first tree
// 	  string tname = string(_tree->GetName());
//           treename += tname;

// 	  if ( tname == "Events" )
// 	    {
// 	      // Found a tree called Events, so use it
// 	      _tree = (TTree*)o;
// 	      break;
// 	    }
// 	}
//       else if ( o->IsA()->InheritsFrom("TDirectory") )
// 	{
// 	  treename += string(o->GetName())+"/";
// 	  treename = _gettree((TDirectory*)o, treename, depth);
// 	}
//     }
//   return treename;
// }
// ------------------------------------------------------------------------
// Get all branches from the root-file, recursively. Create a
// Field for each branch/leaf. By doing this recursively we do not have 
// to know the structure of the tree.
// ------------------------------------------------------------------------
void
itreestream::_getbranches(TBranch* branch, int depth)
{
  depth++;
  if ( depth > 10 ) fatal("_getbranches is lost in tree! Go boil your head!");

  /*
    branchname.push_back(branch->GetName());
    branchtab.push_back(depth);
    _getleaf(branch);            // Create leaf structure for current branch
  */

  // Check current branch for leaves

  TObjArray* array = 0;
  array = branch->GetListOfLeaves();
  if ( array != 0 )
    {
      int nleaves = array->GetEntries();
      for(int i=0; i < nleaves; i++)
        {
          TLeaf* leaf = (TLeaf*)((*array)[i]);
          if ( leaf != 0 )
            {
              _getleaf(branch, leaf); // Create leaf structure
              branchname.push_back(leaf->GetName());
              branchtab.push_back(depth);
            }
        }
    }
  
  // Check current branch for branches. For now, we assume branch names are
  // unique.

  array = 0;
  array = branch->GetListOfBranches();
  if ( array != 0 )
    {
      int nbranches = array->GetEntries();
      for (int i = 0; i < nbranches; i++)
        {
          TBranch* branch_ = (TBranch*)((*array)[i]);
          _getbranches(branch_, depth);
        }
    }
}

// ------------------------------------------------------------------------
// Create a leaf structure
// ------------------------------------------------------------------------
void
itreestream::_getleaf(TBranch* branch, TLeaf* leaf)
{
  if ( branch == 0 ) fatal("_getleaf - branch pointer zero");
  if ( leaf == 0 )
    {
      TObjArray* array = branch->GetListOfLeaves();
      if ( array != 0 ) leaf = (TLeaf*)((*array)[0]);
    }
  if ( leaf == 0 )
    fatal("getleaf - leaf pointer zero for\n"
          "\tbranch " + string(branch->GetName()));

  Field v;
  v.address = 0;      // Set by caller
  v.srctype = 0;      // Set by caller
  v.maxsize = 0;      // Set by caller
  v.isvector= 0;      // Set by caller (1 or 2 if external variable is a vector)

  v.branch  = branch;
  v.leaf    = leaf;

  // get full path to tree
  v.treename= branch->GetTree()->GetName();
  TDirectory* dir = branch->GetTree()->GetDirectory();
  if ( dir )
    {
      string dirname(dir->GetName());
      if ( dirname != string(dir->GetFile()->GetName()) )
	{
	  if ( dirname != "" ) v.treename = dirname + "/" + v.treename;
	}
    }
	 
  v.branchname= branch->GetName();
  v.leafname  = leaf->GetName();
  v.fullname  = v.treename + "/" + v.branchname;
    
  // associate this field with the chain to which it belongs
  string key = v.treename;
  if ( _chainmap.find(key) == _chainmap.end() )
    {
      key = string(branch->GetTree()->GetDirectory()->GetName())
	+ string("/") + v.treename;
      if ( _chainmap.find(key) == _chainmap.end() )
	fatal("getleaf - unable to find chain associated with field " + key);
    }
  v.chain     =_chainmap[key];
  // get first character of type name, which specifies the stored type in the
  // ROOT file.
  v.iotype    = leaf->GetTypeName()[0];
  v.iscounter = false;

  // If the branch contains a single leaf, it is sufficient
  // to identify the leaf with the branch. Otherwise, create
  // a name for each leaf within the branch.
  if ( branch->GetListOfLeaves()->GetEntries() == 1 )
    {
      data[v.fullname] = v;
    }
  else
    {
      v.fullname += + "." + v.leafname;
      data[v.fullname] = v;
    }

  if ( DEBUGLEVEL > 0 ) 
    cout << "getleaf"
	 << " fullname(" << v.fullname << ")"
	 << " treename(" << v.treename << ")"
      	 << " branchname(" << v.branchname << ")"
	 << " iotype(" << v.iotype << ")"
	 << endl;
}

// Shutdown stream

void
itreestream::close()
{
  _statuscode = kSUCCESS;
  
  if ( _tree == 0 ) return;
  DBUG("itreestream::close file", 1);
  if ( _delete ) delete  _tree;
  _tree = 0;
}

bool
itreestream::good() { return _statuscode == kSUCCESS; }

int
itreestream::status() { return _statuscode; }


void 
itreestream::select(string namen, double& d)
{
  _select(namen, &d, 1, 'D');
}

void 
itreestream::select(string namen, float& d)
{
  _select(namen, &d, 1, 'F');
}

void 
itreestream::select(string namen, long& d)
{
  _select(namen, &d, 1, 'L');
}

void 
itreestream::select(string namen, int& d)
{
  _select(namen, &d, 1, 'I');
}

void 
itreestream::select(string namen, short& d)
{
  _select(namen, &d, 1, 'S');
}

void 
itreestream::select(string namen, bool& d)
{
  _select(namen, &d, 1, 'O');
}

void 
itreestream::select(string namen, string& d)
{
  _select(namen, &d, 1, 'C');
}

void 
itreestream::select(string namen, unsigned long& d)
{
  _select(namen, &d, 1, 'l');
}

void 
itreestream::select(string namen, unsigned int& d)
{
  _select(namen, &d, 1, 'i');
}

void 
itreestream::select(string namen, unsigned short& d)
{
  _select(namen, &d, 1, 's');
}


// vector<T>

void 
itreestream::select(string namen, vector<double>& d)
{
  _select(namen, &d, d.size(), 'D', 1);
}

void 
itreestream::select(string namen, vector<float>& d)
{
  _select(namen, &d, d.size(), 'F', 1);
}

void 
itreestream::select(string namen, vector<long>& d)
{
  _select(namen, &d, d.size(), 'L', 1);
}

void 
itreestream::select(string namen, vector<int>& d)
{
  _select(namen, &d, d.size(), 'I', 1);
}

void 
itreestream::select(string namen, vector<short>& d)
{
  _select(namen, &d, d.size(), 'S', 1);
}

void 
itreestream::select(string namen, vector<char>& d)
{
  _select(namen, &d, d.size(), 'B', 1);
}

void 
itreestream::select(string namen, vector<bool>& d)
{
  _select(namen, &d, d.size(), 'O', 1);
}

void 
itreestream::select(string namen, vector<unsigned long>& d)
{
  _select(namen, &d, d.size(), 'l', 1);
}

void 
itreestream::select(string namen, vector<unsigned int>& d)
{
  _select(namen, &d, d.size(), 'i', 1);
}

void 
itreestream::select(string namen, vector<unsigned short>& d)
{
  _select(namen, &d, d.size(), 's', 1);
}

// vector<vector<T> >
void 
itreestream::select(string namen, vector<vector<double> >& d)
{
  _select(namen, &d, d.size(), 'D', 2);
}

void 
itreestream::select(string namen, vector<vector<float> >& d)
{
  _select(namen, &d, d.size(), 'F', 2);
}

void 
itreestream::select(string namen, vector<vector<long> >& d)
{
  _select(namen, &d, d.size(), 'L', 2);
}

void 
itreestream::select(string namen, vector<vector<int> >& d)
{
  _select(namen, &d, d.size(), 'I', 2);
}

void 
itreestream::select(string namen, vector<vector<unsigned long> >& d)
{
  _select(namen, &d, d.size(), 'l', 2);
}

void 
itreestream::select(string namen, vector<vector<unsigned int> >& d)
{
  _select(namen, &d, d.size(), 'i', 2);
}

void 
itreestream::select(string namen)
{
  _bufmap[namen] = _index;
  _select(namen, &_buffer[_index], 1, 'D');
  _index++;
}

void 
itreestream::select(vector<string>& namen)
{
  _bufoffset =_index;
  _bufcount  = namen.size();
  for(unsigned i=0; i < namen.size(); i++) select(namen[i]);
}

vector<double>
itreestream::vget() 
{ 
  vector<double> v(_bufcount);
  for(int i=0; i < _bufcount; i++) v[i] = _buffer[i +_bufoffset];
  return v; 
}

double
itreestream::get(string namen) 
{ 
  if (_bufmap.find(namen) != _bufmap.end())
    return _buffer[ _bufmap[namen] ];
  else
    return 0; 
}

void
itreestream::read(int start, vector<vector<double> >& v) 
{
  if ( v.size() < _bufmap.size() ) return;

  size_t nrows = (size_t)size() < v[0].size() ? (size_t)size() : v[0].size();
  for(size_t c=0; c < nrows; c++)
    {      
      int entry = start + c;
      read(entry);

      int j=0;
      map<string, int>::iterator it = _bufmap.begin();  
      for(it=_bufmap.begin(); it != _bufmap.end(); it++)
	{
	  v[j][c] = _buffer[ it->second ];
	  j++;
	}
    }
}


// ------------------------------------------------------------------------
// Read tree with ordinal value entry.
// ------------------------------------------------------------------------
int 
itreestream::read(int entry)
{
  _statuscode = kSUCCESS;
  // localentry is relative to a tree, while entry is the global ordinal value
  // of event.
  int localentry = 0;

  // If entry is negative, we assume that the tree is already in
  // memory, in which case we do nothing.
  if ( entry > -1 )
    {
      _entry = entry;
      if ( _chain == 0 ) fatal("chain pointer is zero");

      // Load tree into memory

      localentry = _chain->LoadTree(entry);
      
      if (localentry < 0) return localentry;

      if ( DEBUGLEVEL > 0 ) 
        cout << "entry(" << entry << ") "
             << "localentry(" << localentry << ")" << endl;

      // Update pointers to tree, branches and leaves.
      
      if ( _chain->GetTreeNumber() != _current) _update();
    }
  else
    {
      localentry = _entry;

      // Update pointers to tree, branches and leaves.
      
      if ( _tree->GetTreeNumber() != _current) _update();

      _entry++;
    }
     
  // Copy data into external buffers

  SelectedData::iterator it;

  // IMPORTANT: Read leaf counters first...

  for(it=selecteddata.begin(); it != selecteddata.end(); it++)
    {
      Field* field = it->second;
      assert(field != 0);
      if ( field->skip ) continue;
      if ( ! field->iscounter ) continue;
      readbranch(field, localentry);
    }

  // ..then other variables

  for(it=selecteddata.begin(); it != selecteddata.end(); it++)
    {
      Field* field = it->second;
      assert(field != 0);
      if ( field->skip ) continue;
      if ( field->iscounter ) continue;
      readbranch(field, localentry);
    }

  return localentry; // Return ordinal value within current tree.
}

int 
itreestream::entries() { return _entries; }

int 
itreestream::size()    { return _entries; }

string
itreestream::name() { return _tree ? _tree->GetName() : ""; }

string
itreestream::title() { return _tree ? _tree->GetTitle() : ""; }

int 
itreestream::number() { return _current; }

vector<string>
itreestream::names() { return branchname; }

vector<string>
itreestream::filenames() { return filepath; }

string
itreestream::filename() { return filepath[_current]; }

TTree*
itreestream::tree() { return _tree; }

TFile*
itreestream::file() { return ((TChain*)(_tree))->GetFile(); }

string
itreestream::str() const
{
  if ( ! _tree ) return string("");

  ostringstream out;
  out << "File " << _tree->GetCurrentFile()->GetName()      << endl;
  out << "Tree   " << _tree->GetName()      << endl;
  TList* list = _tree->GetListOfFriends();
  if ( list )
    for(int c=0; c < list->GetEntries(); c++)
      {
	TTree* ptree = (TTree*)list->At(c);
	out << "Tree   " << ptree->GetName()      << endl;
      }
  out << "Entries  " << _tree->GetEntries()   << endl;
  out << endl;

  // sort branch names so that all branches per tree occur together
  vector<string> records;
  Data::const_iterator it;
  int count = 0;
  for(it=data.begin(); it != data.end(); it++)
    {
      const Field& field = it->second;
      count++;
      int maxcount = 0;
      TLeaf* leafcounter = field.leaf->GetLeafCounter(maxcount);

      string lfsym("");
      if (field.iscounter) lfsym = string(" *");

      char record[8192];
      if ( leafcounter != 0 )
        {
          // This variable has a leaf counter
          sprintf(record, "%5d %s \t/ %s \t(%d) / %s",
                  count,
                  field.fullname.c_str(),
                  field.leaf->GetTypeName(),
                  leafcounter->GetMaximum(),
		  leafcounter->GetName());
        }
      else
        {
          // This variable does not have a leaf counter
          maxcount = field.leaf->GetLen();
          if ( maxcount > 1 )
            sprintf(record, "%5d %s \t/ %s [%d]",
                    count,
                    field.fullname.c_str(),
                    field.leaf->GetTypeName(), 
                    maxcount);
          else
            sprintf(record, "%5d %s \t/ %s%s",
                    count,
                    field.fullname.c_str(),
                    field.leaf->GetTypeName(),
                    lfsym.c_str());
        }
      records.push_back(record);
    }
  
  sort(records.begin(), records.end());
  for(size_t c=0; c < records.size(); c++)
    out << records[c] << endl;
  return out.str();
}

// ------------------------------------------------------------------------
// The following routine is used to specify the addresses into which data
// are to be read, when reading a Root-file
// Note 1: When itreestream is created a Field object is created for each 
//         branch/leaf in the root-tuple. However, a branch is activated 
//         only if the _select method has been called for that branch and
//         leaf and, of course, only if the named branch/leaf (that is, 
//         variable) exists.
//
// Note 2: The _select/read sequence does not use the internal buffers
//         field.value, but loads data directly into the user's
//         variables.
// ------------------------------------------------------------------------
void 
itreestream::_select(string namen, void* address, int maxsize, char srctype,
                     int isvector)
{
  _statuscode = kSUCCESS;
  
  // If namen does not specify a tree name, then  default to first tree name
  bool treename_specified = false;
  for(size_t i=0; i < _treenames.size(); i++)
    {
      DBUG(string("_select - treename( ") + _treenames[i] + string(" )"));
      string key = _treenames[i] + string("/");
      if ( namen.find(key) != std::string::npos )
	{
	  treename_specified = true;
	  break;
	}
    }
  if ( ! treename_specified )
    {
      namen = _treename + "/" + namen;
      DBUG("_select - WARNING - treename not specified - use: " + _treename);
    }

  // If variable has already been selected, just update its address and
  // source type, otherwise get the branch and leaf.

  if ( DEBUGLEVEL > 0 )
    cout << "_select - " << namen << "\t" 
         << " address: " << address
         << " maxsize: " << maxsize
         << " srctype: " << srctype
         << " isvector: " << isvector
         << endl;
  
  if ( DEBUGLEVEL > 0 )
    cout << "_select - field name(" << namen << ")" << endl;

  // Check for new name
  if ( selecteddata.find(namen) != selecteddata.end() )
    {
      selecteddata[namen]->address = address;
      selecteddata[namen]->srctype = srctype;
    }
  else if ( data.find(namen) != data.end() )
    {
      // Known branch - activate it

      Field& field  = data[namen]; // NB: Get a reference, not a copy!
      field.srctype = srctype;
      field.maxsize = maxsize;
      field.address = address;     // source address
      field.isvector= isvector;
      selecteddata[namen] = &field;

      // If this branch has a branch counter, select its branch unless
      // already selected by caller.

      int count = 0;
      TLeaf* leafcounter = field.leaf->GetLeafCounter(count);
      if ( leafcounter != 0 )
        {
          // Current field has a leaf counter
          
          TBranch* branch = leafcounter->GetBranch();
	  // get full names
          string name_(string(branch->GetTree()->GetName()) +
		       "/" + string(branch->GetName()));
          
          if ( DEBUGLEVEL > 1 )
            cout << "_select - " << namen << " needs counter " 
                 << name_ << endl;
          
          // If leaf counter field not yet created, create it
          if ( selecteddata.find(name_) == selecteddata.end() )
            {
              if ( DEBUGLEVEL > 0 )
                cout << "_select - " << namen << " get counter " 
                     << name_ << endl;
              
              _getleaf(branch);

              // Do not set the address. If needed, it will be set by the 
              // caller in a subsequent call to the select method.
              // If the caller does not need it, then the address field 
              // should remain zero.
              
              Field& f  = data[name_];  // NB: Get a reference, not a copy!
              f.srctype = 'I';          // Default source type
              f.maxsize = 1;
              f.iscounter = true;
              selecteddata[name_] = &f;
            }
        }
    }
  else
    {
      warning("itreestream - branch " + namen + " not found");
      _statuscode = kBADBRANCH;
    }
}  

// ------------------------------------------------------------------------
// Update the branch and leaf pointers. We do this when we switch from one 
// tree, or trees, to another in a chain of Root-files.
// ------------------------------------------------------------------------
void 
itreestream::_update()
{
  _statuscode = kSUCCESS; 
  if ( _chain != 0 )
    _current = _chain->GetTreeNumber();
  else
    _current = _tree->GetTreeNumber();

  SelectedData::iterator it;
  for(it=selecteddata.begin(); it != selecteddata.end(); it++)
    {
      Field* field = it->second;
      if ( field == 0 )  fatal("update - zero field pointer");

      if ( field->chain == 0 ) fatal("update - zero field->chain pointer");
      
      field->branch = field->chain->GetBranch(field->branchname.c_str());
      if ( field->branch == 0 )
        { 
          fatal("update - pointer is zero for tree/branch (" 
                  + field->fullname + ")");
          field->branch = 0;
          field->leaf   = 0;
          continue;
        }
      field->leaf = field->branch->GetLeaf(field->leafname.c_str());
      if ( field->leaf == 0 ) fatal("update - pointer is zero for leaf "
                             + field->leafname);

      // Let Root handle types that are stored as STL vectors
      if ( field->iotype == 'v')
        {
	  if ( field->isvector == 1 )
	    {
	      switch(field->srctype)
		{
		case 'D':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<double>**)&field->address),
						 &field->branch);
		  break;
        
		case 'F':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<float>**)&field->address),
						 &field->branch);
		  break;
		  
		case 'L':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<long>**)&field->address),
						 &field->branch);
		  break;

		case 'I':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<int>**)&field->address),
						 &field->branch);
		  break;

		case 'S':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<short>**)&field->address),
						 &field->branch);
		  break;

		case 'B':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<char>**)&field->address),
						 &field->branch);
		  break;

		case 'O':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<bool>**)&field->address),
						 &field->branch);
		  break;

		case 'C':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<string>**)&field->address),
						 &field->branch);
		  break;
		  
		case 'l':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<unsigned long>**)&field->address),
						 &field->branch);
		  break;
        
		case 'i':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<unsigned int>**)&field->address),
						 &field->branch);
		  break;
	      
		case 's':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<unsigned short>**)&field->address),
						 &field->branch);
		  break;
	      
		case 'b':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<unsigned char>**)&field->address),
						 &field->branch);
		  break;
		  
		default:
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<double>**)&field->address),
						 &field->branch);
		  break;
		}	  	      
	    }
	  else
	    {
	      // handle vector<vector<T> >
	      switch(field->srctype)
		{
		case 'D':	      
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<vector<double> >**)&field->address),
						 &field->branch);
		  break;
	      
		case 'F':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<vector<float> >**)&field->address),
						 &field->branch);
		  break;
        
		case 'L':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<vector<long> >**)&field->address),
						 &field->branch);
		  break;

		case 'I':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<vector<int> >**)&field->address),
						 &field->branch);

		case 'l':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<vector<unsigned long> >**)
						  &field->address),
						 &field->branch);
		  break;

		case 'i':
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<vector<unsigned int> >**)
						  &field->address),
						 &field->branch);
		default:
		  field->chain->SetBranchAddress(field->branchname.c_str(), 
						 ((vector<double>**)&field->address),
						 &field->branch);
		  break;
		}	  
	    }
	}
      else if ( field->maxsize < 1 )
        fatal("_update - external buffer for " 
              + field->fullname + " is of zero length!");
    }
  DBUG("\tdone updating branch pointers", 1);
}

int 
itreestream::maximum(string name_)
{
  if ( data.find(name_) != data.end() )
    return getmaxsize(data[name_].leaf);
  else
    return 1;
}

bool
itreestream::present(string name_) { return data.find(name_) != data.end(); }

// int 
// itreestream::operator[](int entry) 
// {
//   int ev = read(entry);
//   if ( ev < 0 )
//     {
//       PyErr_SetString(PyExc_IndexError, "index out of range");
//       boost::python::throw_error_already_set(); // bail out
//     } 
//   return ev; 
// }

std::ostream& operator<<(std::ostream& os, const itreestream& tuple)
{
  os << tuple.str();
  return os;
}

// ------------------------------------------------------------------------
// W R I T E
// ------------------------------------------------------------------------
otreestream::otreestream()
  : _file(0),
    _tree(0),
    _statuscode(kSUCCESS),
    _entries(0)
{}

otreestream::otreestream(std::string filename, 
                         std::string treename, 
                         std::string title_,
                         int complevel,
                         int bufsize)
  : _file(0),
    _tree(0),
    _statuscode(kSUCCESS),
    _entries(0),
    _idatabuf(0),
    _databuf(vector<double>(bufsize)),
    _autosavecount(-1)
{
  DBUG("create file "+filename,1);

  _file = TFile::Open(filename.c_str(), "RECREATE");
  //_file = new TFile(filename.c_str(), "RECREATE");
  if ( ! _file )
    {
      cerr << "itreestream **Error** unable to open " << filename << endl;
      _statuscode = kBADOPEN;
      return;
    }
  _file->SetCompressionLevel(complevel);
  _file->cd();

  _tree = new TTree(treename.c_str(), title_.c_str());
  if ( ! _tree )
    {
      cerr << "itreestream **Error** can't make tree " << treename << endl;
      _statuscode = kBADTREE;
      return;
    }
}

otreestream::otreestream(TFile* file_, 
                         std::string treename, 
                         std::string title_,
                         int complevel,
                         int bufsize)
  : _file(file_),
    _tree(0),
    _statuscode(kSUCCESS),
    _entries(0),
    _idatabuf(0),
    _databuf(vector<double>(bufsize)),
    _autosavecount(-1)
{
  if ( ! _file )
    {
      cerr << "otreestream **Error** TFile pointer is zero" << endl;
      _statuscode = kBADOPEN;
      assert(_file);
      return;
    }
  _file->SetCompressionLevel(complevel);
  _file->cd();

  _tree = new TTree(treename.c_str(), title_.c_str());
  if ( ! _tree )
    {
      cerr << "otreestream **Error** can't make tree " << treename << endl;
      _statuscode = kBADTREE;
      return;
    }
}

otreestream::~otreestream()
{
  _statuscode = kSUCCESS;
  close();
}

void
otreestream::close(bool closefile)
{
  _statuscode = kSUCCESS;

  if ( _file == 0 ) return;
  
  DBUG("otreestream::close file (before)", 1);

  SelectedData::iterator it = selecteddata.begin();
  while ( it != selecteddata.end() ) 
    {
      delete it->second;
      it->second = 0;
      it++;
    }
  DBUG("otreestream::close file (after)", 1);

  if ( closefile )
    {
      _file->Write(0, TObject::kOverwrite); //kWriteDelete
      _file->Close(); // causes a crash in ROOT 
      delete _file;

      _tree = 0;
      _file = 0;
    }
}

bool
otreestream::good() { return _statuscode == kSUCCESS; }

int
otreestream::status() { return _statuscode; }

string
otreestream::name() { return _tree ? _tree->GetName() : ""; }

string
otreestream::title() { return _tree ? _tree->GetTitle() : ""; }


void
otreestream::add(string namen, double& datum)
{
  _add(namen, &datum, 1, 'D', 'D');
}

void
otreestream::add(string namen, float& datum)
{
  _add(namen, &datum, 1, 'F', 'F');
}

void
otreestream::add(string namen, long& datum)
{
  _add(namen, &datum, 1, 'L', 'L');
}

void
otreestream::add(string namen, int& datum)
{
  _add(namen, &datum, 1, 'I', 'I');
}

void
otreestream::add(string namen, short& datum)
{
  _add(namen, &datum, 1, 'S', 'S');
}

void
otreestream::add(string namen, bool& datum)
{
  _add(namen, &datum, 1, 'O', 'O');
}

void
otreestream::add(string namen, string& datum)
{
  _add(namen, &datum, 1, 'C', 'C');
}

void
otreestream::add(string namen, unsigned int& datum)
{
  _add(namen, &datum, 1, 'i', 'i');
}

void
otreestream::add(string namen, unsigned short& datum)
{
  _add(namen, &datum, 1, 's', 's');
}

// Vectors

void 
otreestream::add(string namen, vector<double>& d)
{
  _add(namen, &d, d.size(), 'D', 'D', true);
}

void 
otreestream::add(string namen, vector<float>& d)
{
  _add(namen, &d, d.size(), 'F', 'F', true);
}

void 
otreestream::add(string namen, vector<long>& d)
{
  _add(namen, &d, d.size(), 'L', 'L', true);
}

void 
otreestream::add(string namen, vector<int>& d)
{
  _add(namen, &d, d.size(), 'I', 'I', true);
}

void 
otreestream::add(string namen, vector<short>& d)
{
  _add(namen, &d, d.size(), 'S', 'S', true);
}

void 
otreestream::add(string namen, vector<bool>& d)
{
  _add(namen, &d, d.size(), 'O', 'O', true);
}

void 
otreestream::add(string namen, vector<unsigned int>& d)
{
  _add(namen, &d, d.size(), 'i', 'i', true);
}

void 
otreestream::add(string namen, vector<unsigned short>& d)
{
  _add(namen, &d, d.size(), 's', 's', true);
}

void 
otreestream::add(string namen)
{
  if ( (unsigned)_idatabuf >= _databuf.size() )
    {
      cout << "You need to increase internal buffer size" << endl;
      cout << "It is currently set to " << _databuf.size() << endl;
      exit(0);
    }
  _add(namen, &_databuf[_idatabuf], 1, 'D', 'D');
  _idatabuf++;
}

// ------------------------------------------------------------------------
// Copy each variable from external buffer to internal buffer, taking 
// care of type conversions. Then store data away.
// ------------------------------------------------------------------------
void
otreestream::insert(vector<double>& data) 
{ 
  copy(data.begin(), data.end(), _databuf.begin());
}

void
otreestream::store() 
{ 
  DBUG("BEGIN store");
  _statuscode = kSUCCESS;
  _entry = _entries;

  map<string, int> counter;

  SelectedData::iterator it;

  for(it = selecteddata.begin(); it != selecteddata.end(); it++)
    {
      Field* field  = it->second;
      assert(field);
      assert(field->leaf);

      if ( DEBUGLEVEL > 0 )
	cout << "commit( " + string(field->leaf->GetName()) << " )" << endl;

      // if this is a leaf counter; apparently, need to store explicitly (Root v6.16/00)
      if ( field->iscounter )
	{
	  fromexternal<int>(field);
	  continue;
	}
      
      // Ok, get the count for this variable.
      int len = getexsize(field);
      if ( DEBUGLEVEL > 0 )
	cout << "\tcommit size: " << len 
	     << "\tfield->maxsize: " << field->maxsize << endl;
      
      field->size = min(len, field->maxsize); // update count

      if ( DEBUGLEVEL > 0 )
	cout << "\tfield->size: " << field->size << endl;      
      
      // If the variable has a leafcounter update size field of the leaf counter
      int flag = 0;
      TLeaf* leafcounter = field->leaf->GetLeafCounter(flag);
      if ( leafcounter != 0 )
	{
	  string name_(leafcounter->GetName());
	  if ( DEBUGLEVEL > 0 )
	    cout << "\tfound leaf counter( " << name_ << " ) size: " << field->size
		 << "\tfor " << field->leaf->GetName() << endl;
	  if ( selecteddata.find(name_) != selecteddata.end() )
	    selecteddata[name_]->size = field->size;
	  else
	    fatal("no selectedata structure for leaf count " + name_);
	}
       

      
      // Copy data to internal buffers from external buffers
      // iotype <- srctype

      switch(field->iotype)
        {
        case 'D':
          fromexternal<double>(field);
          break;
          
        case 'F':
          fromexternal<float> (field);
          break;
          
        case 'L':
          fromexternal<long>  (field);
          break;
          
        case 'I':
          fromexternal<int>   (field);
          break;

        case 'S':
          fromexternal<short> (field);
          break;

        case 'B':
          fromexternal<char> (field);
          break;

        case 'O':
          fromexternal<bool> (field);
          break;

        case 'C':
          fromexternal<string> (field);
          break;

        case 'l':
          fromexternal<unsigned long>  (field);
          break;
          
        case 'i':
          fromexternal<unsigned int>   (field);
          break;

        case 's':
          fromexternal<unsigned short> (field);
          break;
          
        default:
          fromexternal<double>(field);
          break;
        }
    }
  DBUG("END store");
  DBUG("");
}

void
otreestream::save()
{
  // ..and store away.

  _file->cd();
  _tree->Fill();
  _entries++;

  //   // Save header every _autosavecount events
  //   if ( _entries % _autosavecount == 0 )
  //     {
  //       cout << _entries << "\totreestream::commit is saving header" << endl;
  //       _tree->AutoSave("SaveSelf");
  //     }
}

void
otreestream::commit()
{
  store();
  save();
}

void
otreestream::autosave(int count) 
{ 
  // count in Mbytes
  _autosavecount = count;
  if ( _autosavecount > 0 ) _tree->SetAutoSave(_autosavecount * 1000000);
}

int 
otreestream::entries() { return _entries; }

int 
otreestream::size()    { return _entries; }

vector<string>
otreestream::names() { return branchname; }

TFile*
otreestream::file() { return _file; }

TTree*
otreestream::tree() { return _tree; }

string 
otreestream::str() const
{
  ostringstream out;
  out << "Tree Name          " << _tree->GetName()      << endl;
  out << "Number of entries  " << _tree->GetEntries()   << endl;
  out << "Number of branches " << _tree->GetNbranches() << endl;
  return out.str();
}

void
otreestream::ls(ostream& out)
{
  out << str();
}

// ------------------------------------------------------------------------
// Create branch, of given type - int, float or double. The method can be 
// called repeatedly for the same branch name. On the first call the branch 
// is created and the address of the source variable is set. On subsequent 
// calls the address is reset.
// ------------------------------------------------------------------------
void 
otreestream::_add(string namen, void* address, int maxsize,
                  char srctype, char iotype, int isvector)
{
  DBUG("\n_add: BEGIN");

  DBUG(string("_add: srctype: ") + srctype + string("\tiotype: ") + iotype);
    
  _statuscode = kSUCCESS;
  if ( maxsize < 1 )
    fatal("add - external buffer for " + namen + " is of zero length!");
  
  int k = namen.find("/");
  if ( k > -1 ) namen = namen.substr(0, k);

  // Get format
  char format[256];
  char IOtype[2] = {iotype, 0};
  sprintf(format, "%s/%s", namen.c_str(), IOtype);

  // This could be a variable length array with name: <name>[countername].
  // if so, strip away [<countername>]
  k = namen.rfind("[");
  string countername("");
  if ( k >= 0 )
    {
      int j = namen.rfind("]");
      countername = namen.substr(k+1, j-k-1);
      namen = namen.substr(0,k);
    }

  if ( DEBUGLEVEL > 0 )
    cout << "variable( " << namen << " ) countername(" <<  countername << ")" << endl;
  
  // If branch is not present, create it; otherwise 
  // just set the source address.

  if ( selecteddata.find(namen) == selecteddata.end() )
    {        
      Field field;
      field.srctype   = srctype;
      field.iotype    = iotype;
      field.address   = address; // Source address
      field.maxsize   = maxsize;
      field.size      = 0;
      field.isvector  = isvector;
      field.branchname= namen;
      field.fullname  = namen;
      field.countername = countername;
      
      // Allocate a buffer of appropriate type and size
      // and create a corresponding branch

      switch(iotype)
        {
        case 'D':
          createbranch<double>(_tree, &field, format, selecteddata);
          break;

        case 'F':
          createbranch<float> (_tree, &field, format, selecteddata);
          break;
          
        case 'L':
          createbranch<long>  (_tree, &field, format, selecteddata);
          break;
          
        case 'I':
          createbranch<int>   (_tree, &field, format, selecteddata);
          break;
          
        case 'S':
          createbranch<short> (_tree, &field, format, selecteddata);
          break;

        case 'B':
          createbranch<char>  (_tree, &field, format, selecteddata);
          break;

        case 'O':
          createbranch<int>   (_tree, &field, format, selecteddata);
          break;

        case 'C':
          createbranch<string>(_tree, &field, format, selecteddata);
          break;

        case 'l':
          createbranch<unsigned long>  (_tree, &field, format, selecteddata);
          break;
          
        case 'i':
          createbranch<unsigned int>   (_tree, &field, format, selecteddata);
          break;
          
        case 's':
          createbranch<unsigned short> (_tree, &field, format, selecteddata);
          break;
    
        case 'b':
          createbranch<unsigned char>  (_tree, &field, format, selecteddata);
          break;

        default:
          fatal(string("add - unsupported type ") + iotype);
        }
    }
  else
    // Update source address, because it may have changed.
    selecteddata[namen]->address = address;

  DBUG("_add: END");
}

std::ostream& operator<<(std::ostream& os, const otreestream& tuple)
{
  os << tuple.str();;
  return os;
}

